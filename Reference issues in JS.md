## JS中的引用问题

#### 场景1 变量

 let a = null; 
 let b = 20; 
 a = b; 
 a 指向的是否是b的地址？

在JS中，let 声明用于声明可重新赋值的块级作用域局部变量²。let 声明的变量只能在执行到声明所在的位置之后才能被访问²。let 声明的变量的作用域只在其声明的块或子块内部²。

在您的代码中，您先用 let 声明了两个变量 a 和 b ，并分别赋值为 null 和 20 。然后，您又将 b 的值赋给了 a 。这时，a 指向的是 b 的值，而不是 b 的地址。因为在JS中，基本类型的值（如数字、字符串、布尔值、null 和 undefined ）是按值传递的，也就是说，当赋值或传参时，会创建一个副本，而不是引用原来的值³。所以，a 和 b 是两个独立的变量，它们的值相同，但它们的地址不同。

如果您想要让 a 指向 b 的地址，您可以使用对象类型的值（如数组、函数、对象等），因为对象类型的值是按引用传递的，也就是说，当赋值或传参时，会共享同一个内存地址，而不是创建一个新的地址³。例如：

```javascript
let a = null;
let b = [20]; // 创建一个数组对象
a = b; // 将 b 的引用赋给 a
console.log(a); // [20]
console.log(b); // [20]
console.log(a === b); // true，说明 a 和 b 指向同一个地址
b[0] = 30; // 修改 b 的值
console.log(a); // [30]，说明 a 的值也跟着变化
console.log(b); // [30]
```

#### 场景2 对象

```javascript
let obj = { a: null, b: 20 }; // 创建一个对象
obj.a = obj.b; // 将 b 的值赋给 a
```

这样，obj.a 指向的是 obj.b 的值，而不是 obj.b 的地址。因为 obj.b 的值是一个基本类型的值（数字），而基本类型的值是按值传递的，也就是说，当赋值或传参时，会创建一个副本，而不是引用原来的值。所以，obj.a 和 obj.b 是两个独立的属性，它们的值相同，但它们的地址不同。

如果让 obj.a 指向 obj.b 的地址，可以使用对象类型的值（如数组、函数、对象等），因为对象类型的值是按引用传递的，也就是说，当赋值或传参时，会共享同一个内存地址，而不是创建一个新的地址。例如：

```javascript
let obj = { a: null, b: [20] }; // 创建一个对象，b 的值是一个数组对象
obj.a = obj.b; // 将 b 的引用赋给 a
console.log(obj.a); // [20]
console.log(obj.b); // [20]
console.log(obj.a === obj.b); // true，说明 obj.a 和 obj.b 指向同一个地址
obj.b[0] = 30; // 修改 b 的值
console.log(obj.a); // [30]，说明 obj.a 的值也跟着变化
console.log(obj.b); // [30]
```
